---
title: C#-(2) 기본 개념
layout: single
author_profile: true
read_time: true
comments: true
share: true
related: true
categories:
- C#
toc: true
toc_sticky: true
toc_label: 목차
---

## 연산자

### 연산자 개요
- 변수 데이터를 연산해 다양한 결과를 얻기 위해 사용
- 결과 값을 대입하는 대입 연산자부터 사칙연산을 하는 산술 연산자 등 제공
![그림5](https://user-images.githubusercontent.com/37354978/121845493-7c1f3680-cd20-11eb-9fe7-188257649d7c.png)

### 대입(할당) 연산자
- 결과값을 댕비하는 연산자로 여러 연산을 축약한 대입 연산자도 제공
![그림6](https://user-images.githubusercontent.com/37354978/121845747-dc15dd00-cd20-11eb-8350-a634e3ff1bf2.png)

### 비교(관계) 연산자
- 양쪽의 값을 비교하여 결과를 참(true) 또는 거짓(false)으로 나타내는 연산자
![그림7](https://user-images.githubusercontent.com/37354978/121846193-99083980-cd21-11eb-8aab-d52619a3cc79.png)

### 비교(관계) 연산자
- 양쪽의 값을 비교하여 결과를 참(true) 또는 거짓(false)으로 나타내는 연산자
![그림8](https://user-images.githubusercontent.com/37354978/121846516-12a02780-cd22-11eb-8f18-7701fc3ca7ee.png)

### 조건(삼항) 연산자
- 조건식을 사용해 조건식의 참, 거짓 여부에 따라 다른 결과 값 대입
![그림9](https://user-images.githubusercontent.com/37354978/121846523-13d15480-cd22-11eb-998a-3f54bb7787cb.png)

### 비트 연산자
- 비트 단위의 데이터 연산에 사용
- 시프트 연산의 장점 : 연산 속도가 빠르다
- 시프트 연산의 단점 : 머리로 계산이 잘 안된다
![그림10](https://user-images.githubusercontent.com/37354978/121846751-79254580-cd22-11eb-93fd-f4ae5d8792e7.png)

### 비트 논리 연산자
![그림11](https://user-images.githubusercontent.com/37354978/121848024-6ca1ec80-cd24-11eb-8929-a29c76fb9fca.png)

### 연산자 우선순위
- 연산자마다 우선순위가 정해져 있다
- 우선순위가 같을 경우 왼쪽의 연산자를 먼저 계산한다
- 괄호 안에 있는 연산자가 우선 계산된다
- 우선순위가 헷갈리면 괄호로 구분하는게 최고다
![그림12](https://user-images.githubusercontent.com/37354978/121848327-db7f4580-cd24-11eb-8568-5d97728711b3.png)

## 조건문

### 조건문 개요
- 조건문은 설정한 조건이 참(true) 또는 거짓(false)일 때 코드를 실행하거나 실행하지 않고 넘어가서 프로그램의 흐름을 여러 갈래로
나누는 제어문이다.
- 조건문에는 if와 switch-case가 있으며, if의 경우 if, else if, else로 나눌 수 있다
![그림13](https://user-images.githubusercontent.com/37354978/121848677-547e9d00-cd25-11eb-8881-2d99b4d08048.png)

### if
- if의 조건이 참이면 if 조건식 뒤의 중괄호 내부를 실행하고,
거짓이면 실행하지 않고 넘어간다
![그림14](https://user-images.githubusercontent.com/37354978/121848847-94de1b00-cd25-11eb-8194-fe5636d32997.png)


### SerializeField 어트리뷰트
- ex) [SerializeField]
- ex) private int x = 10;
- 클래스 멤버 변수를 선언할 때 변수 앞 또는 바로 윗줄에 작성하면 유니티 에디터 Inspector View에서 해당 클래스 멤버 변수 값을 설정할 수 있다.

### if-else
- if의 조건이 참(true)이면 if 중괄호 내부를 실행하고, 거짓(false)이면 else 중괄호 내부를 실행한다. 
![그림15](https://user-images.githubusercontent.com/37354978/121849748-b8559580-cd26-11eb-88cf-b7178e04625e.png)

### if-else if - else
- if의 조건이 참(true)이면 if 내부를 실행하고, 거짓(false)이면 else if의 조건 2를 실행한다
- else if의 조건 2가 참(true)이면 else if 내부를 실행하고, 거짓이면(false)이면 else를 실행한다
![그림16](https://user-images.githubusercontent.com/37354978/121850233-6cefb700-cd27-11eb-9da2-fefdbc536dff.png)

### switch - case
- switch에 조건을 검사할 변수를 설정한다
- 조건에 해당하는 것이 case 뒤에 있는 값이다
- 위의 조건을 모두 만족하지 않을 때 제일 아래에 작성된 default가 실행된다 (if 조건문의 else와 같은 역할을 수행)
- switch - case에서 break는 중단의 역할을 하기 때문에 break가 없다면 다른 case의 조건도 이어서 실행하게 된다
![그림17](https://user-images.githubusercontent.com/37354978/121850457-c35cf580-cd27-11eb-8f6a-cefdd535f34a.png)

## 반복문 

### 반복문 개요
- 반복문은 설정한 조건이 거짓이 될 때까지 코드 블록 내부를 반복해서 실행한다
- 반복문에는 for, while, do-while이 있다
![그림18](https://user-images.githubusercontent.com/37354978/121850808-47af7880-cd28-11eb-95a1-6753729a4a38.png)

### for
- for 괄호 내부에 초기화, 조건, 증감 연산자와 같이 3개의 연산자를 작성하며, 초기화한 변수가 반복문 내부를 1회 실행할 때만다 증감 연산자에 의해 값이 바뀜
- 이 값이 조건을 만족하지 않을 때까지 반복해서 실행한다.
![그림19](https://user-images.githubusercontent.com/37354978/121851277-e3d97f80-cd28-11eb-86e1-0e8879e21ccc.png)
![그림20](https://user-images.githubusercontent.com/37354978/121851288-e63bd980-cd28-11eb-8e46-253b5ed00535.png)

### while
- for와 다르게 괄호 내부에 조건만 들어간다
- 조건을 만족하지 않을 때까지 반복 실행하는 것은 동일하다
- 조건에 사용되는 변수의 초기화와 증감 연산은 알아서 작성해야한다
- 보통 초기화는 while()문 위의 작성하며, 증감 연산은 while()문 내부의 가장 아래에 작성한다
- 실행 구조는 for문과 유사하다.
![그림21](https://user-images.githubusercontent.com/37354978/121852347-5139e000-cd2a-11eb-947e-bddf51deeba2.png)
![그림22](https://user-images.githubusercontent.com/37354978/121852352-539c3a00-cd2a-11eb-922d-4eb3bf6fe52a.png)
![그림23](https://user-images.githubusercontent.com/37354978/121852469-7d556100-cd2a-11eb-9707-f9b4a89d8afc.png)

### do-while
- for, while문은 조건을 먼저 검사하기 때문에 조건이 맞지 않으면 단 1번도 실행되지 않는다.
- 반면, do-while은 일단 한번은 조건 없이 실행하고, 그 후에 조건을 검사해 반복해서 실행한다.
![그림24](https://user-images.githubusercontent.com/37354978/121852729-db824400-cd2a-11eb-9b1c-b525c25935ea.png)
![그림25](https://user-images.githubusercontent.com/37354978/121852866-0d93a600-cd2b-11eb-8ec4-3ff60c025d32.png)

### 무한 루프
- 반복문은 정해진 회수만큼 반복한 후 종료하지만, 이를 정해진 회수 없이 무한하게 실행하도록 할 수 있다
- 반복문 내부 또는 다른 곳에서 이 반복문을 종료시킬 수 있는 코드를 반드시 작성해야한다.
![그림26](https://user-images.githubusercontent.com/37354978/121853090-6b27f280-cd2b-11eb-814f-c77606a485ee.png)

### 무한 루프 사용 방법
- for 반복문은 세미콜론 사이에 들어가는 문장을 작성하지 않으면 된다
- while, do-while은 조건에 true를 작성해 조건이 계속 참이 되도록 설정한다

### 점프문 break, continue
- 흐름을 끊고 프로그램의 실행 위치를 원하는 곳으로 이동시킨다
- break : 현재 실행중인 반복문이나 switch문의 실행을 중단할 때 사용한다
- continue : 반복문에서 현재 조건을 건너뛴다

## 배열

### 배열이란?
- 같은 형식의 데이터를 한 그룹으로 묶어서 사용하는 것

### 배열이 필요한 이유?
- 5마리의 적이 있다고 가정할 때, 5마리의 적의 체력을 담는 변수 선언
![그림27](https://user-images.githubusercontent.com/37354978/121854119-b55da380-cd2c-11eb-81e1-9dfdfbc9b3de.png)
- **만약 이러한 적이 50마리라고 한다면? 50개의 변수 선언 ?**
- 변수를 50개 선언해야할까?

### 배열의 선언
![그림28](https://user-images.githubusercontent.com/37354978/121854382-0d94a580-cd2d-11eb-8855-86d1d80ad51f.png)

### 배열에 값 저장하기
![그림29](https://user-images.githubusercontent.com/37354978/121854389-0ec5d280-cd2d-11eb-87fb-d472381c85a9.png)

### 배열의 장점
- 선언 뿐만 아니라 사용할 때도 개수만큼의 줄 수가 필요한 변수와 달리 배열은 반복문을 이용해 한번에 사용 가능
![그림30](https://user-images.githubusercontent.com/37354978/121854616-5cdad600-cd2d-11eb-98de-51d9ac76ac1a.png)

### 배열의 초기화
- 첫번째 방법은 배열의 원소 개수를 명시, 그 뒤에 중괄호 { 와 }로 둘러싸인 블록을 붙인 뒤, 블록 사이에 배열의 각 원소에 입력될 데이터 입력
![그림31](https://user-images.githubusercontent.com/37354978/121854874-acb99d00-cd2d-11eb-9724-0d8ecbc6a734.png)

- 두번째 방법은 첫번째 방법에서 배열의 용량을 생략
![그림32](https://user-images.githubusercontent.com/37354978/121854961-c4912100-cd2d-11eb-9c6e-167301398a65.png)

- 세번째 방법은 new 연산자, 형식과 괄호 '[' ']'배열의 용량 모두 생략
![그림33](https://user-images.githubusercontent.com/37354978/121855164-015d1800-cd2e-11eb-8730-9030ce13a15a.png)

### System.Array
- .NET 프레임워크의 CTS(Common Type System)에서 제공하는 배열
- Array 클래스의 주요 메소드와 프로퍼티
![그림34](https://user-images.githubusercontent.com/37354978/121855497-5e58ce00-cd2e-11eb-947f-5ff395d1acdc.png)

### 2차원 배열의 선언
- (세로 +가로) 형태로 된 배열로 차원의 크기를 콤마(,)로 구분해서 입력
![그림35](https://user-images.githubusercontent.com/37354978/121855935-dd4e0680-cd2e-11eb-8624-17e3d971e288.png)
![그림36](https://user-images.githubusercontent.com/37354978/121856000-f5258a80-cd2e-11eb-9b57-e2bd51651ef7.png)

### 가변 배열(Jagged Array)
- Jagged의 뜻은 "들쭉날쭉한" 이라는 뜻
- 말 그대로 1차원의 크기를 들쭉날쭉 다르게 설정할 수 있다
![그림37](https://user-images.githubusercontent.com/37354978/121856276-49306f00-cd2f-11eb-8e5e-7debf2ef5854.png)

## 메소드

### 메소드란?
- 객체 지향 프로그래밍 언어에서 사용하는 용어
- 유사한 용어 (사용하는 언어에 따라 다르게 부르기도 한다)
- 함수 (Function)
- 서브루틴 (SubRoutine)
- 프로시져 (Procedure)
- 서브 프로그램 (SubProgram)

### 메소드 정의
- "방법"이라는 뜻으로 객체의 일을 처리하는 방법을 정의
- 일련의 코드를 하나의 이름 아래 묶은 것
- 묶어 놓은 코드는 메소드의 이름을 불러 내부 코드들을 실행할 수 있다
![그림38](https://user-images.githubusercontent.com/37354978/121856988-16d34180-cd30-11eb-86f1-0e7e890559b6.png)

### 메소드의 예
![그림39](https://user-images.githubusercontent.com/37354978/121857316-74678e00-cd30-11eb-8617-c2ffdf43bc98.png)

https://www.youtube.com/watch?v=o0Pklkow-AA&list=PLC2Tit6NyVicT5cCqILMWXpXVEoM9ufyH&index=11
02:08

